<?php

/**
 * @file
 * Code for the commerce_reservations features.
 */

include_once('commerce_reservations.features.inc');

/**
 * Include Open Media System Equipment Reservation Reports
 */
include_once('commerce_reservations.om_reports.inc');

/*
 * Implements hook_permission()
 */
function commerce_reservations_permission() {
  return array(
    'administer commerce reservations' => array(
      'title' => t('Administer commerce reservations'),
      'description' => t('Access configuration settings for commerce reservations'),
    ),
    'cancel own commerce reservations' => array(
      'title' => t('Cancel own commerce reservations'),
      'description' => t('Cancel own commerce reservations'),
    ),
  );
}

/*
 * Implements hook_form_FORM_ID_alter()
 */

function commerce_reservations_form_commerce_product_ui_product_form_alter(&$form, &$form_state, $form_id){
  if (isset($form['field_crp_product_title'])) {
    if ($form['field_crp_product_title']['und']['#bundle'] == 'reservable_product') {
      $form['title']['#value'] = 'ant';
      $form['title']['#type'] = 'value';
      $form['title']['#required'] = FALSE;
      $form['#validate'][] .= 'commerce_reservations_taxonomy_title';
    }
  }
}

function commerce_reservations_taxonomy_title(&$form, &$form_state){
  $form_state['values']['title'] = $form_state['values']['field_crp_product_title']['und'][0]['name'];
  $form_state['complete form']['title']['#value'] = $form_state['values']['field_crp_product_title']['und'][0]['name'];
}

/*
 * Implements hook_init()
 */

function commerce_reservations_init(){
  $path = drupal_get_path('module', 'commerce_reservations');
  if (arg(0) == 'reservations'){
    drupal_add_js($path . '/js/commerce_reservations.fullcalendar.js', array('type' => 'file', 'weight' => 1));
    drupal_add_js($path . '/js/product_filter.js', array('type' => 'file', 'weight' => 2));
    drupal_add_css($path . '/theme/reservations.css');
  }
  if (arg(0) == 'administer_reservations') {
    drupal_add_css($path . '/theme/reservations.css');
  }

  if (variable_get('cr_expired_cart_warning', 0)) {
    global $user;
    if ($cart = commerce_cart_order_load($user->uid)) {
      $time_lapse = time() - $cart->created;
      $minutes = $time_lapse / 60;

      if ($minutes > 10) {
        $cart = l('Click here to review your order and continue', 'cart');
        drupal_set_message('You started an order that has not been completed. '.$cart.'. Incomplete orders older than 60 minutes will be deleted.', 'warning', FALSE);
      } 
    }
  }
}



/**
 * Implements hook_fullcalendar_api().
 */
function commerce_reservations_fullcalendar_api() {
  return array(
    'api' => fullcalendar_api_version(),
    'path' => drupal_get_path('module', 'commerce_reservations') . '/includes',
  );
}

/**
 * Implements hook_block_info().
 */

function commerce_reservations_block_info(){
  $blocks = array();
//This block will be used to create an area to display item info on the calendar page
  $blocks['item_info'] = array(
    'info' => t('Item Information')
  );
  
  return $blocks;
}


/**
 * Implements hook_block_view()
 */
 
function commerce_reservations_block_view($delta = ''){
  $block = array();
  
  switch ($delta) {    
    case 'item_info':
      $block['subject'] = 'Item Info';
      $block['content'] = theme('commerce_reservations_item_info', array('block_delta' => $delta));
      break;
    }
  return $block;
}

/*
 *  Implements hook_theme
 */

function commerce_reservations_theme(){
	return array(
	  'commerce_reservations_item_info' => array(
	    'template' => 'commerce_reservations_item_info',
	    'path' => drupal_get_path('module', 'commerce_reservations') . '/theme',
	    'file' => 'theme.inc',
	    'variables' => array(
	      'block_delta' => NULL,
	    ),
	  ),
	);
}

/*
 * Implements hook_menu
 */
 
function commerce_reservations_menu(){
  $items['res-cal/%/%'] = array(
    'page callback' => 'calendar_filter',
    'page arguments' => array(1, 2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['cr/res_checkout'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_reservations_line_item_checkout_form', 2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['cr/res_checkin'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_reservations_line_item_checkin_form', 2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['cr/res_cancel'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_reservations_line_item_cancel_form', 2),
    'access callback' => 'commerce_reservations_cancel_reservation_access',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  $items['cr/res_noshow'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_reservations_line_item_noshow_form', 2),
    'access arguments' => array('administer commerce reservations'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/commerce/cr/settings'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_reservations_settings_form'),
    'access arguments' => array('administer commerce reservations'),
    'title' => t('Commerce Reservations Settings'),
    'type' => MENU_LOCAL_TASK,
  );
  $items['cr/missing-accessories-confirm/%/%'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('missing_accessories_confirm', 2, 3),
    'access arguments' => array('administer commerce reservations'),
    'type' => MENU_CALLBACK,
  );
  $items['closed_times'] = array(
    'page callback' => 'commerce_reservations_get_closed_times',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['cr/max_hours'] = array(
    'page callback' => 'commerce_reservations_get_max_hours',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['cr/res_window'] = array(
    'page callback' => 'commerce_reservations_get_reservation_window',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['cr/product_form/%'] = array(
    'page callback' => 'commerce_reservations_add_to_cart_form',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['cr/product_add'] = array(
    'page callback' => 'commerce_reservations_cart_submission',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/*
 *  Implements hook_form_alter
 */
 
function commerce_reservations_form_alter(&$form, &$form_state, $form_id){
  $commerce_reservations = array(
    'staff' => false,
  );

  global $user;
  if (in_array('Staff Member', $user->roles)) {
    $commerce_reservations['staff'] = true;
  }
  drupal_add_js(array('commerce_reservations' => $commerce_reservations), 'setting');

  $my_form_id = substr($form_id, 0, 30);
  if ($my_form_id == 'commerce_cart_add_to_cart_form'){
    //we have to cache as it is being loaded via ajax
  /*
   *  Here we will grab the number of products tied to the product display, and use that as the quantity.  We need the quantity to have      	 *	a number to check against in the reservations system.
   */
    if ($form['line_item_fields']['#bundle'] == 'reservable_product'){
      $display = commerce_reservations_entity_display_lookup($form['product_id']['#value']);
      $display_node = node_load($display);
      if (!empty($display_node->field_crp_product_reference['und'])) {
        $max_quantity = count($display_node->field_crp_product_reference['und']);
      }else{
        $max_quantity = 1;
      }

      //check against quantity ovverrides
      $quantity_limit = commerce_reservations_get_max_quantity($display_node->nid);
      if (!empty($quantity_limit) && $quantity_limit < $max_quantity) {
        $max_quantity = $quantity_limit;
      }

      $options = array();
      for ($i = $max_quantity; $i > 0; $i--){
        $options[] = $i;
      }
      sort($options);
      $form['quantity']['#type'] = 'select';
      $form['quantity']['#options'] = drupal_map_assoc($options);
      $form['quantity']['#multiple'] = FALSE;
      $form['quantity']['#weight'] = 0;
      $form['quantity']['#title'] = 'QUANTITY';
      unset($form['quantity']['#size']);
      $form['submit']['#value'] = 'Add Rental to Shopping Cart'; 
      $form['#validate'][] = 'commerce_reservations_fix_quantity';
      $form['#validate'][] = 'commerce_reservations_check_availability';
      $form['#submit'][] = 'commerce_reservations_redirect_add';
    }
  }
  //Make the quantity non-editable on the cart if the line item is a reservable product
  if ($form_id == 'views_form_commerce_cart_form_default') {
    $index = 0;
    foreach($form['edit_quantity'] as $quantity_field){
      if (isset($quantity_field['#line_item_id'])){
	      $line_item = commerce_line_item_load($form['edit_quantity'][0]['#line_item_id']);
	      if ($line_item->type == 'reservable_product'){
		      $form['edit_quantity'][$index]['#disabled'] = TRUE;
		      $index ++;
	      }
      }
    }
  }

  //set default reservation date and time to last reservation in cart if available
  if (strpos($form_id, 'commerce_cart_add_to_cart_form') !== false) {
    //set quantity weight to appear above other items
    global $user;
    if ($order = commerce_cart_order_load($user->uid)) {
      if ($last_reservation = commerce_reservations_last_cart_reservation($order)) {
        if (strtotime($last_reservation->field_reservation_dates[LANGUAGE_NONE][0]['value']) > time()) {
          $form['line_item_fields']['field_reservation_dates'][LANGUAGE_NONE][0]['#default_value'] = $last_reservation->field_reservation_dates[LANGUAGE_NONE][0];
        }
      }
    } 
  }

  if ($form_id == 'reservable_product_display_node_form') {
    $availability_items = commerce_reservations_availability_form_items($form, $form_state);
    $form['reservable_product_availability'] = array(
      '#type' => 'fieldset',
      '#weight' => 50,
      '#title' => t('Availability Overrides'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    if (!empty($GLOBALS['availability_override'])) {
      $form['reservable_product_availability']['#collapsed'] = FALSE;
    }
    $form['reservable_product_availability'] += $availability_items;
    $form['#submit'][] = 'commerce_reservations_availability_items_submit'; 
  }
}

function commerce_reservations_redirect_add($form, &$form_state) {
  $form_state['redirect'] = 'reservations';
} 

function commerce_reservations_last_cart_reservation($order) {
  if ($order) {
    if (!empty($order->commerce_line_items)) {
      foreach($order->commerce_line_items['und'] AS $line_item) {
        $line_item = commerce_line_item_load($line_item['line_item_id']);
        $product = commerce_product_load($line_item->commerce_product['und'][0]['product_id']);
        if ($product->type == 'reservable_product') {
          $last_reservation = $line_item;
        }
      }
    }
  }

  if (!empty($last_reservation)) {
    return $last_reservation;
  }
  else {
    return FALSE;
  }
}


/**
 * This is a giant hack for quantity problem until I have time
 * to create a better solution.
 */
function commerce_reservations_fix_quantity($form, &$form_state) {
  if (!empty($form_state['input']['quantity']) && is_numeric($form_state['input']['quantity'])) {
    $form_state['values']['quantity'] = $form_state['input']['quantity'];
  }
}

function commerce_reservations_get_glocal($nid, $key) {
  $nid_value = variable_get($nid . '_' . $key, null);

  if (is_null($nid_value) || !is_numeric($nid_value)) {
    $value = variable_get($key, 0);
  }
  else {
    $value = variable_get($nid . '_' . $key);
  }

  return $value;
}

function commerce_reservations_get_max_hours($nid) {
  print commerce_reservations_get_glocal($nid, 'cr_max_reservation_length');
}

function commerce_reservations_get_max_quantity($nid) {
  return commerce_reservations_get_glocal($nid, 'cr_max_quantity');
}

function commerce_reservations_get_reservation_window($nid) {
  $days = commerce_reservations_get_glocal($nid, 'cr_reservation_window');
  if (empty($days) || $days > 90) {
    $days = 90;
  }
  print $days;
}

//Get the closed dates and times so we can add them to the calendar
function commerce_reservations_get_closed_times($display_nid = false){
  $total = commerce_reservations_availability_var_get('cr_closed_total', NULL, $display_nid);
  $closed_dates = array();
  for ($i = 0; $i < $total; $i++){
    $variable = 'cr_closed_dates_' . $i;
    $date = commerce_reservations_availability_var_get($variable, NULL, $display_nid);
    $array = explode('-', $date);
    $closed_dates[] = $array[2] . '-' . $array[0] . '-' . $array[1];
  }
  $days = commerce_reservations_week_days();
  $closed_days = array();
  foreach ($days as $day){
    $variable = 'cr_' . $day;
    if (commerce_reservations_availability_var_get($variable, NULL, $display_nid) == 'closed'){
      $closed_days[$day] = commerce_reservations_availability_var_get($variable, NULL, $display_nid);
    }
  }
  $all_days_closed = array();
  foreach ($closed_days as $day => $value){
    switch ($day){
      case 'Sunday':
        $array = getDateForSpecificDayBetweenDates('today', '+3 month', 0);
        $all_days_closed = array_merge($all_days_closed, $array);
        break;
      case 'Monday':
        $array = getDateForSpecificDayBetweenDates('today', '+3 month', 1);
        $all_days_closed = array_merge($all_days_closed, $array);
        break;
      case 'Tuesday':
        $array = getDateForSpecificDayBetweenDates('today', '+3 month', 2);
        $all_days_closed = array_merge($all_days_closed, $array);
        break;
      case 'Wednesday':
        $array = getDateForSpecificDayBetweenDates('today', '+3 month', 3);
        $all_days_closed = array_merge($all_days_closed, $array);
        break;
      case 'Thursday':
        $array = getDateForSpecificDayBetweenDates('today', '+3 month', 4);
        $all_days_closed = array_merge($all_days_closed, $array);
        break;
      case 'Friday':
        $array = getDateForSpecificDayBetweenDates('today', '+3 month', 5);
        $all_days_closed = array_merge($all_days_closed, $array);
        break;
      case 'Saturday':
        $array = getDateForSpecificDayBetweenDates('today', '+3 month', 6);
        $all_days_closed = array_merge($all_days_closed, $array);
        break;
    }
  }

  //wrapper to allow blocking or non-blocking events
  $blocking = commerce_reservations_availability_var_get('cr_availability_blocking', NULL, $display_nid);
  if (!$blocking) {
    $blocking_value = 'non-blocking';
  }
  else {
    $blocking_value = 'blocking';
  }

  print '<div class = "closed-dates-wrapper" data-blocking = "'.$blocking_value.'">';
  $closed_dates = array_merge($closed_dates, $all_days_closed);
  foreach($closed_dates as $date){
    print '<div class = "closed_dates" date = "' . $date . '"></div>'; 
  }
  print '</div>';
  $closed_hours = array();
  print '<div class = "closed-times-wrapper" data-blocking = "'.$blocking_value.'">';
  foreach ($days as $day){
    $variable = 'cr_' . $day . '_hours';
    $value = commerce_reservations_availability_var_get($variable, NULL, $display_nid);
    if ($value && !empty($value['open']) && !empty($value['closed'])){
      switch($day){
        case 'Sunday':
          $array = getDateForSpecificDayBetweenDates('today', '+3 month', 0);
          $previous = 'Saturday';
          $variable2 = 'cr_' . $previous . '_hours';
          $next = 'Monday';
          $variable3 = 'cr_' . $next . '_hours';
          $value3 = commerce_reservations_availability_var_get($variable3, NULL, $display_nid);
          foreach($array as $index => $date){
            $value2 = commerce_reservations_availability_var_get($variable2, NULL, $display_nid);
            print commerce_reservations_generate_date_feed_item($date, $index, $value, $value2, $value3, 6); 
          }
          break;
        case 'Monday':
          $array = getDateForSpecificDayBetweenDates('today', '+3 month', 1);
          $previous = 'Sunday';
          $variable2 = 'cr_' . $previous . '_hours';
          $next = 'Tuesday';
          $variable3 = 'cr_' . $next . '_hours';
          $value3 = commerce_reservations_availability_var_get($variable3, NULL, $display_nid);
          foreach($array as $index => $date){
            $value2 = commerce_reservations_availability_var_get($variable2, NULL, $display_nid);
            print commerce_reservations_generate_date_feed_item($date, $index, $value, $value2, $value3, 0); 
          }
          break;
        case 'Tuesday':
          $array = getDateForSpecificDayBetweenDates('today', '+3 month', 2);
          $previous = 'Monday';
          $variable2 = 'cr_' . $previous . '_hours';
          $next = 'Wednesday';
          $variable3 = 'cr_' . $next . '_hours';
          $value3 = commerce_reservations_availability_var_get($variable3, NULL, $display_nid);
          foreach($array as $index => $date){
            $value2 = commerce_reservations_availability_var_get($variable2, NULL, $display_nid);
            print commerce_reservations_generate_date_feed_item($date, $index, $value, $value2, $value3, 1); 
          }
          break;
        case 'Wednesday':
          $array = getDateForSpecificDayBetweenDates('today', '+3 month', 3);
          $previous = 'Tuesday';
          $variable2 = 'cr_' . $previous . '_hours';
          $next = 'Thursday';
          $variable3 = 'cr_' . $next . '_hours';
          $value3 = commerce_reservations_availability_var_get($variable3, NULL, $display_nid);
          foreach($array as $index => $date){
            $value2 = commerce_reservations_availability_var_get($variable2, NULL, $display_nid);
            print commerce_reservations_generate_date_feed_item($date, $index, $value, $value2, $value3, 2); 
          }
          break;
        case 'Thursday':
          $array = getDateForSpecificDayBetweenDates('today', '+3 month', 4);
          $previous = 'Wednesday';
          $variable2 = 'cr_' . $previous . '_hours';
          $next = 'Friday';
          $variable3 = 'cr_' . $next . '_hours';
          $value3 = commerce_reservations_availability_var_get($variable3, NULL, $display_nid);
          foreach($array as $index => $date){
            $value2 = commerce_reservations_availability_var_get($variable2, NULL, $display_nid);
            print commerce_reservations_generate_date_feed_item($date, $index, $value, $value2, $value3, 3); 
          }
          break;
        case 'Friday':
          $array = getDateForSpecificDayBetweenDates('today', '+3 month', 5);
          $previous = 'Thursday';
          $variable2 = 'cr_' . $previous . '_hours';
          $next = 'Saturday';
          $variable3 = 'cr_' . $next . '_hours';
          $value3 = commerce_reservations_availability_var_get($variable3, NULL, $display_nid);
          foreach($array as $index => $date){
            $value2 = commerce_reservations_availability_var_get($variable2, NULL, $display_nid);
            print commerce_reservations_generate_date_feed_item($date, $index, $value, $value2, $value3, 4); 
          }
          break;
        case 'Saturday':
          $array = getDateForSpecificDayBetweenDates('today', '+3 month', 6);
          $previous = 'Friday';
          $variable2 = 'cr_' . $previous . '_hours';
          $next = 'Sunday';
          $variable3 = 'cr_' . $next . '_hours';
          $value3 = commerce_reservations_availability_var_get($variable3, NULL, $display_nid);
          foreach($array as $index => $date){
            $value2 = commerce_reservations_availability_var_get($variable2, NULL, $display_nid);
            print commerce_reservations_generate_date_feed_item($date, $index, $value, $value2, $value3, 5); 
          }
          break;
      }
    }
  }
  print '</div>'; 
}

function commerce_reservations_generate_date_feed_item($date, $index, $value, $value2, $value3, $date_modifier) {
  $output = '';
  if ($value2 && !empty($value2['open']) && !empty($value2['closed'])){
    $array2 = getDateForSpecificDayBetweenDates('today -1 day', '+3 month', $date_modifier);
    $start_date = commerce_reservations_format_calendar_date($array2[$index] . ' ' . $value2['closed']);
    $end_date = commerce_reservations_format_calendar_date($date . ' ' . $value['open']);
    //GIANT hack need to find problem later 5/22 10:00 pm to 8/21 2:00pm
    if (strtotime($end_date) - strtotime($start_date) > (24*60*60)) { return; } 
    $output .= '<div class = "closed-time" start = "' . $start_date . '" ' . 'end = "' . $end_date . '"></div>';
  } else{
    $start_date = commerce_reservations_format_calendar_date($date . ' 12:00 am');
    $end_date = commerce_reservations_format_calendar_date($date . ' ' . $value['open']);
    if (strtotime($end_date) - strtotime($start_date) > (24*60*60)) { return; } 
    $output .= '<div class = "closed-time" start = "' . $start_date . '" end = "' . $end_date . '"></div>';
  }
  if (!$value3 || empty($value3['open']) || empty($value3['closed'])){
    $start_date = commerce_reservations_format_calendar_date($date . ' ' . $value['closed']);
    $end_date = commerce_reservations_format_calendar_date($date . ' 11:59 pm');
    if (strtotime($end_date) - strtotime($start_date) > (24*60*60)) { return; } 
    $output .= '<div class = "closed-time" start = "' . $start_date . '" end = "' . $end_date . '"></div>';
  }

  return $output;
}

function commerce_reservations_format_calendar_date($date_string) {
  $clean_date = date('Y-m-d H:i:s', strtotime($date_string));
  return $clean_date;
}

//This is the ajax function which provides our view filter based on product id
function calendar_filter($pid, $node, $quantity = 0){
  global $user;
  $account = user_load($user->uid);
  $product = commerce_product_load($pid);
  $display_nid = commerce_reservations_entity_display_lookup($pid);
  $display_node = node_load($display_nid);
  $display_node->user_access = true;
  $display_node->user_access_message = ''; 

  //product access checks
  if (module_exists('rules') && $user->uid != 1) {
    rules_invoke_event('om_membership_product_access', $user, $display_node, $product);
  }
  $is_certified = FALSE;
  if ($product->field_certifications_required['und'] && $user->uid != 1) {
    foreach($product->field_certifications_required['und'] as $product_cert){
      //if (in_array($account->roles, $product_cert['rid'])) {
      if (isset($account->roles[$product_cert['rid']])) {
        $is_certified = TRUE;
        break;
      }
    }
  }
  else {
    $is_certified = TRUE;
  }
  if ($display_node->user_access && !$is_certified) {
    $display_node->user_access_message = 'You do not have the required certification to reserve this item.';
    $display_node->user_access = false;
  }

  if (!$display_node->user_access) {
    $error_output = '';
    $error_output .= '<div>';
    $error_output .= '<div id="no-access">';
    $error_output .= '<div id="no-access-message">';
    $error_output .= $display_node->user_access_message;
    $error_output .= '</div>';
    if (!empty($display_node->user_access_blink) && !empty($display_node->user_access_btext)) {
      $error_output .= '<div id="no-access-button">';
      $error_output .= '<a href="'.$display_node->user_access_blink.'">';
      $error_output .= $display_node->user_access_btext;
      $error_output .= '</a>';
      $error_output .= '</div>';
    }
    $error_output .= '</div></div>';
    print $error_output;
    return;
  }
  
  if ($is_certified){
	  $args = array();
    $display_nid = commerce_reservations_entity_display_lookup($pid);
    $display_node = node_load($display_nid);
    foreach ($display_node->field_crp_product_reference[$display_node->language] as $key => $info) {
      $pids[] = $info['product_id']; 
    }
    $pid_string = implode("+", $pids);

    //here we need to get ALL potential pids in product display
    $args[] = $pid_string;

    //load reservations as user as 1 to circumvent line item access
    global $user;
    $original_user = $user;
    $old_state = drupal_save_session();
    drupal_save_session(FALSE);
    $user = user_load(1);

    $view = views_get_view('reservation_calendar');
    $nid = str_replace('node-', '', $node);
    $view->selected_nid = $nid;
    $view->quantity = $quantity;
    $display = $view -> preview('page_1', $args);

    $user = $original_user;
    drupal_save_session($old_state);
    //back to normal user at this point

    print $display;
  } else {
    print '<div><div id = "not_certified"></div></div>';
    $allow_commercial = variable_get('cr_allow_commercial', 0);
    if ($allow_commercial == 1){
	    print '<div><div id = "allow_commercial"</div></div>';
    }
  }
}

//Here we intercept the view result and check the results for overlaps
function commerce_reservations_views_post_execute(&$view){
  if ($view->name == 'reservation_calendar'){
    if (sizeof($view->args) > 0){
      //create the reservation array, passing start end and line_id
      $reservations = array();
      foreach ($view->result as $reservation){
        $quantity = $reservation->_field_data['line_item_id']['entity']->quantity;
        for ($i = 0; $i < $quantity; $i++){
          if ($i > 0){
            $j = $i + 1;
            $reservations[] = array(
              'start' => strtotime($reservation->field_field_reservation_dates[0]['raw']['value']),
              'end' => strtotime($reservation->field_field_reservation_dates[0]['raw']['value2']),
              'line_id_array' => array($reservation->line_item_id . "-" . $j),
              'count' => 1
            );
          } else {
            $reservations[] = array(
              'start' => strtotime($reservation->field_field_reservation_dates[0]['raw']['value']),
              'end' => strtotime($reservation->field_field_reservation_dates[0]['raw']['value2']),
              'line_id_array' => array($reservation->line_item_id),
              'count' => 1
            );
          }
        }
      } 
      //pass the array of reservations to the check_overlaps function
      $overlaps = check_overlaps($reservations, $reservations);
      $result = new stdClass();
      if (!empty($view->result)) {
        foreach($view->result[0] as $key => $value){
          $result->{$key} = $value;
        }
      }
      $array_size = sizeof($view->result);
      for ($i = 0; $i < $array_size; $i++){
        unset($view->result[$i]);
      }
      if (!empty($overlaps)){
      //loop through and add in overlaps, remove view results
        foreach($overlaps as $index => $reservation){
          if (property_exists($view, 'selected_nid')){
            $nid = $view->selected_nid;
            $node = node_load($nid);
            $available = sizeof($node->field_crp_product_reference['und']);  //number of products tied to the product display
            $quantity = $view->quantity;
            //number we have - the number of overlapping reservations - the number the user wants to check out must be greater than zero
            if (($available - $overlaps[$index]['count']) - $quantity < 0){  
              $view->result[$index] = $result;
              $result = new stdClass();
              foreach($view->result[$index] as $key => $value){
                $result->{$key} = $value;
              }
              $view->result[$index]->field_field_reservation_dates[0]['raw']['value'] = date("Y-m-d H:i:s", $overlaps[$index]['start']);
              $view->result[$index]->field_field_reservation_dates[0]['raw']['value2'] = date("Y-m-d H:i:s", $overlaps[$index]['end']);
              $view->result[$index]->line_item_id = $overlaps[$index]['line_id_array'][0];
            }
          }
        }
        $view->result = array_values($view->result);
        $view = check_view_overlaps($view);
      } else{
        if (property_exists($view, 'selected_nid')){
          $nid = $view->selected_nid;
          $node = node_load($nid);
          $available = sizeof($node->field_crp_product_reference['und']);
          if ($available > 1){
            foreach($view->result as $index => $reservation){
              unset($view->result[$index]);
            }
          }
        }
      }
    } else{
      foreach($view->result as $index => $result){
        unset($view->result[$index]);
      }
    }
  } elseif ($view->name == 'reservations_cart'){
    $line_ids = array();
    $line_items = array();
    foreach($view->result as $line_id){
      $line_ids[] = $line_id->commerce_line_item_field_data_commerce_line_items_line_item_;
    }
    foreach($line_ids as $line_id){
      $line_item = commerce_line_item_load($line_id);  
      commerce_cart_order_refresh($line_item->order_id);
    }
  }
}

function getDateForSpecificDayBetweenDates($startDate, $endDate, $weekdayNumber){
  //we dont want to deal with timezones in here
  date_default_timezone_set('UTC');

  $startDate = strtotime($startDate);
  $endDate = strtotime($endDate);
  $dateArr = array();
  do {
    if(date("w", $startDate) != $weekdayNumber){
      $startDate += (24 * 3600); // add 1 day
    }
  } 
  while(date("w", $startDate) != $weekdayNumber);

  while($startDate <= $endDate){
    $dateArr[] = date('Y-m-d', $startDate);
    $startDate += (7 * 24 * 3600); // add 7 days
  }
  return($dateArr);
}

//this function is recursive.  It initially checks the reservations for overlapping times, and returns overlaps as 
//an array of start and end dates.  It then runs again on the array it returned, until there are no more overlaps.

function check_overlaps($reservations = array(), $return_array = array()){
  $overlappin_happened = FALSE;
  $res_size = sizeof($reservations);
  $overlaps = array();
  $index = - 1;
  if ($res_size > 1){
    for ($i = 0; $i < $res_size; $i++){
      for ($j = $i + 1; $j < $res_size; $j++){
        if (array_key_exists($i, $reservations)){
          if (array_key_exists($j, $reservations)){
            if (($reservations[$i]['start'] < $reservations[$j]['end'] && $reservations[$i]['end'] > $reservations[$j]['start']) || ($reservations[$j]['start'] < $reservations[$i]['end'] && $reservations[$j]['end'] > $reservations[$i]['start'])){  
              $overlappin_happened = TRUE;
              if ($reservations[$i]['start'] == $reservations[$j]['start'] && $reservations[$i]['end'] == $reservations[$j]['end']){
                $index ++;
                $overlaps[$index]['line_id_array'] = array();
                $overlaps[$index]['line_id_array'] = $reservations[$i]['line_id_array'];
                foreach($reservations[$j]['line_id_array'] as $new_id){
                  if (!in_array($new_id, $overlaps[$index]['line_id_array'])){
                    $overlaps[$index]['line_id_array'][] = $new_id;
                  } 
                }
                $overlaps[$index]['count'] = sizeof($overlaps[$index]['line_id_array']);
                $overlaps[$index]['start'] = $reservations[$i]['start'];
                $overlaps[$index]['end'] = $reservations[$i]['end'];
                foreach($overlaps as $index2 => $overlap){
                  if ($index != $index2){
                    if ($overlaps[$index]['line_id_array'] == $overlap['line_id_array']){
                      if ($overlaps[$index]['start'] == $overlap['start'] && $overlaps[$index]['end'] == $overlap['end']){
                        unset($overlaps[$index]);
                        $overlaps = array_values($overlaps);
                      }
                    }
                  }
                }
                unset($reservations[$j]);
                $j = $j -1;
                $reservations = array_values($reservations);
              } else{
                $index ++;
                $overlaps[$index]['line_id_array'] = array();
                $overlaps[$index]['line_id_array'] = $reservations[$i]['line_id_array'];
                foreach($reservations[$j]['line_id_array'] as $new_id){
                  if (!in_array($new_id, $overlaps[$index]['line_id_array'])){
                    $overlaps[$index]['line_id_array'][] = $new_id;
                  } 
                }
                $overlaps[$index]['count'] = sizeof($overlaps[$index]['line_id_array']);
                if ($reservations[$i]['start'] <= $reservations[$j]['start']){
                  $overlaps[$index]['start'] = $reservations[$j]['start'];
                } else{
                  $overlaps[$index]['start'] = $reservations[$i]['start'];
                }
                if ($reservations[$i]['end'] <= $reservations[$j]['end']){
                  $overlaps[$index]['end'] = $reservations[$i]['end'];
                } else{
                  $overlaps[$index]['end'] = $reservations[$j]['end'];
                }
                foreach($overlaps as $index2 => $overlap){
                  if ($index != $index2){
                    if ($overlaps[$index]['line_id_array'] == $overlap['line_id_array']){
                      if ($overlaps[$index]['start'] == $overlap['start'] && $overlaps[$index]['end'] == $overlap['end']){
                        unset($overlaps[$index]);
                        $overlaps = array_values($overlaps);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ($overlappin_happened){
   $return_array = array_merge($return_array, $overlaps);
   $return_array = check_overlaps($overlaps, $return_array);
  }
  return $return_array;
}

function check_view_overlaps(&$view){
  $overlappin_happened = FALSE;
  $res_size = sizeof($view->result);
  if ($res_size > 1){
    for ($i = 0; $i < $res_size; $i++){
      for ($j = $i + 1; $j < $res_size; $j++){
        if (array_key_exists($i, $view->result)){
          if (array_key_exists($j, $view->result)){
            $i_start = strtotime($view->result[$i]->field_field_reservation_dates[0]['raw']['value']);
            $i_end = strtotime($view->result[$i]->field_field_reservation_dates[0]['raw']['value2']);
            $j_start = strtotime($view->result[$j]->field_field_reservation_dates[0]['raw']['value']);
            $j_end = strtotime($view->result[$j]->field_field_reservation_dates[0]['raw']['value2']);
            if ($i_start ==  $j_start && $i_end == $j_end){
              $overlappin_happened = TRUE;
              unset($view->result[$j]);
              $j = $j -1;
              $view->result = array_values($view->result);
            } elseif (($i_start <= $j_end && $i_end >= $j_start) || ($j_start <= $i_end && $j_end >= $i_start)){
              $overlappin_happened = TRUE;
              if ($j_start <= $i_start){
                $view->result[$i]->field_field_reservation_dates[0]['raw']['value'] = $view->result[$j]->field_field_reservation_dates[0]['raw']['value'];
              } 
              if ($i_end <= $j_end){
                $view->result[$i]->field_field_reservation_dates[0]['raw']['value2'] = $view->result[$j]->field_field_reservation_dates[0]['raw']['value2'];
              }
              unset($view->result[$j]); 
              $j = $j -1;
              $view->result = array_values($view->result);
            }
          }
        }
      }
    }
  }
  if ($overlappin_happened){
   $view = check_view_overlaps($view);
  }
  return $view;
}

/**
 * Implementation of hook_rules_condition_info()
 */

function commerce_reservations_rules_condition_info() {
  return array(
    'commerce_reservations_product_type_check' => array(
      'label' => t('Order contains a reservation'),
      'arguments' => array(
        'commerce_order' => array('label' => t('Commerce Order'), 'type' => 'commerce_order'),
      ),
      'help' => t('This condition checks to see if this order has a reservation.'),
      'module' => 'commerce_reservations',
      'group' => t('Commerce Reservations Rules'),
    ),
    'commerce_reservations_charge_by_the_day_check' => array(
      'label' => t('Check if daily charge line item'),
      'arguments' => array(
        'lid' => array(
          'label' => t('Line Item ID'), 
          'type' => 'integer'
        ),
      ),
      'help' => t('This condition checks to see if the line item product should be charged daily.'),
      'module' => 'commerce_reservations',
      'group' => t('Commerce Reservations Rules'),
    ),
    'commerce_reservations_charge_by_the_hour_check' => array(
      'label' => t('Check if hourly charge line item'),
      'arguments' => array(
        'lid' => array(
          'label' => t('Line Item Id'),
          'type' => 'integer'
        ),
      ),
      'help' => t('This condition checks to see if the line item product should be charged hourly.'),
      'module' => 'commerce_reservations',
      'group' => t('Commerce Reservations Rules'),
    ),
    'commerce_reservations_check_hours' => array(
      'label' => t('Check for a specified number of hours on a reservation'),
      'parameter' => array(
        'commerce_line_item' => array(
          'type' => 'commerce_line_item',
          'label' => t('Commerce Line Item'),
        ),
        'operator' => array(
          'type' => 'text',
          'label' => t('Operator'),
          'description' => t('The comparison operator.'),
          'optional' => TRUE,
          'default value' => '=',
          'options list' => 'commerce_numeric_comparison_operator_options_list',
          'restriction' => 'input',
        ),
        'hours' => array(
          'type' => 'integer',
          'label' => t('Hours'),
          'description' => t('The corresponding price value that should be compared against.'),
        ),
      ),
      'help' => t('This condition checks to see if the duration of a reservation is of a specified length'),
      'module' => 'commerce_reservations',
      'group' => t('Commerce Reservations Rules'),
    ),
  );
}

/**
 * Condition callback: compares hours to user entered.
 */
function commerce_reservations_check_hours($line_item, $operator, $hours) {
  //bail if dates are missing...
  if (empty($line_item->field_reservation_dates[LANGUAGE_NONE][0]['value']) || empty($line_item->field_reservation_dates[LANGUAGE_NONE][0]['value2'])) {
    return FALSE;
  }

  //calculate duration of reservation
  $total_hours = commerce_reservations_line_item_duration($line_item);
  
  // Make a quantity comparison based on the operator.
  switch ($operator) {
    case '<':
      return $total_hours < $hours;
    case '<=':
      return $total_hours <= $hours;
    case '=':
      return $total_hours == $hours;
    case '>=':
      return $total_hours >= $hours;
    case '>':
      return $total_hours > $hours;
  }

  return FALSE;
}

/**
 * Condition callback to check whether or not an order contains a reservation. Thanks Leo!
 */
function commerce_reservations_product_type_check($order) {
  if ($order) {
    if (!empty($order->commerce_line_items)){
      foreach($order->commerce_line_items['und'] AS $line_item) {
        $line_item = commerce_line_item_load($line_item['line_item_id']);
        $product = commerce_product_load($line_item->commerce_product['und'][0]['product_id']);
        if (!empty($product) && $product->type == 'reservable_product') {
          return TRUE;
        }
      }
    }
  }
  return FALSE;
}

/**
 * Condition callback to check whether or not a line item product should be charged daily
 */
function commerce_reservations_charge_by_the_day_check($lid) {
	if (is_numeric($lid)) {
	  $line_item = commerce_line_item_load($lid);
      $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
	  $product = $line_item_wrapper->commerce_product->value();
	  $product_wrapper = entity_metadata_wrapper('commerce_product', $product);
      if ($product_wrapper->field_charge_by_the_->value() == 'day') {
	    return TRUE;
      }
	}
	return FALSE;
}

/**
 * Condition callback to check whether or not a line item product should be charged hourly
 */
function commerce_reservations_charge_by_the_hour_check($lid) {
	if (is_numeric($lid)) {
	  $line_item = commerce_line_item_load($lid);
      $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
	  $product = $line_item_wrapper->commerce_product->value();
	  $product_wrapper = entity_metadata_wrapper('commerce_product', $product);
      if ($product_wrapper->field_charge_by_the_->value() == 'hour') {
	      return TRUE;
      }
	}
	return FALSE;
}


/**
 * Condition callback to check whether or not an reservation is commercial.
 */
 
function commerce_reservations_commercial_check($line_id){
  $line_item = commerce_line_item_load($line_id);
  if (!empty($line_item->field_commercial_reservation['und'][0]['value']) && $line_item->field_commercial_reservation['und'][0]['value'] == 1){
	  return TRUE;
  }
  return FALSE;
}

function commerce_reservations_hours_days($start, $end) {
  $hours_diff = floor(($end - $start) / 3600);
  if ($hours_diff < 1){
    $hours = 1;
  }else{
    $hours = $hours_diff;
  }
  if ($hours_diff >= 24) {
    $days = floor($hours_diff/24); 
    $remainder_hours = floor($hours_diff - ($days*24));
  }else{
    $days = 1;
    $remainder_hours = 0;
  }

  $hours_days = array(
    'hours' => $hours,
    'days' => $days,
    'remainder_hours' => $remainder_hours,
  );

  return $hours_days;
}

function commerce_reservations_status_options () {
  $states = commerce_reservations_commerce_order_status_info();
  $options = array();
  foreach($states as $key => $info) {
    $options[$info['title']] = $info['title'];
  } 
  return $options;
}

function commerce_reservations_commercial_price_per_hour($line_item, $component_name, $round_mode){
  $product = commerce_product_load($line_item->commerce_product['und'][0]['product_id']);
  if ($product->type != 'reservable_product') {
    return;
  }
  $wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $unit_price = commerce_price_wrapper_value($wrapper, 'commerce_unit_price', TRUE);
  
  if (property_exists($line_item, "field_reservation_dates")){
    $start = strtotime($line_item->field_reservation_dates['und'][0]["value"]);
    $end = strtotime($line_item->field_reservation_dates['und'][0]["value2"]);
    $hours_diff = floor(($end - $start) / 3600);
    if ($hours_diff < 1){
	    $hours_diff = 1;
    }
    $commercial_rate = $product->field_commercial_cost['und'][0]['amount'];
    $updated_price = $hours_diff * $commercial_rate;
    $current_amount = $unit_price['amount'];
    $difference = array(
      'amount' => $updated_price - $current_amount,
      'currency_code' => $unit_price['currency_code'],
      'data' => array(),
    );
   
    // Set the amount of the unit price and add the difference as a component.
    $wrapper->commerce_unit_price->amount = $updated_price;
    
    $wrapper->commerce_unit_price->data = commerce_price_component_add(
      $wrapper->commerce_unit_price->value(),
      $component_name,
      $difference,
      TRUE
    );
  }
}

function commerce_reservations_member_price_per_hour($line_item, $component_name, $round_mode){
  $product = commerce_product_load($line_item->commerce_product['und'][0]['product_id']);
  if ($product->type != 'reservable_product') {
    return;
  }
  $wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $unit_price = commerce_price_wrapper_value($wrapper, 'commerce_unit_price', TRUE);
  
  if (property_exists($line_item, "field_reservation_dates")){
    $start = strtotime($line_item->field_reservation_dates['und'][0]["value"]);
    $end = strtotime($line_item->field_reservation_dates['und'][0]["value2"]);
    $hours_diff = floor(($end - $start) / 3600);
    if ($hours_diff < 1){
	    $hours_diff = 1;
    }
    $commercial_rate = $product->field_member_cost['und'][0]['amount'];
    $updated_price = $hours_diff * $commercial_rate;
    $current_amount = $unit_price['amount'];
    $difference = array(
      'amount' => $updated_price - $current_amount,
      'currency_code' => $unit_price['currency_code'],
      'data' => array(),
    );
   
    // Set the amount of the unit price and add the difference as a component.
    $wrapper->commerce_unit_price->amount = $updated_price;
    
    $wrapper->commerce_unit_price->data = commerce_price_component_add(
      $wrapper->commerce_unit_price->value(),
      $component_name,
      $difference,
      TRUE
    );
  }
}

function commerce_reservations_commercial_price_per_day($line_item, $component_name, $round_mode){
  $product = commerce_product_load($line_item->commerce_product['und'][0]['product_id']);
  if ($product->type != 'reservable_product') {
    return;
  }
  $wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $unit_price = commerce_price_wrapper_value($wrapper, 'commerce_unit_price', TRUE);
  
  if (property_exists($line_item, "field_reservation_dates")){
    $start = strtotime($line_item->field_reservation_dates['und'][0]["value"]);
    $end = strtotime($line_item->field_reservation_dates['und'][0]["value2"]);
    $days_diff = floor(($end - $start) / 86400);
    if ($days_diff < 1){
	    $days_diff = 1;
    }
    $commercial_rate = $product->field_commercial_cost['und'][0]['amount'];
    $updated_price = $days_diff * $commercial_rate;
    $current_amount = $unit_price['amount'];
    $difference = array(
      'amount' => $updated_price - $current_amount,
      'currency_code' => $unit_price['currency_code'],
      'data' => array(),
    );
   
    // Set the amount of the unit price and add the difference as a component.
    $wrapper->commerce_unit_price->amount = $updated_price;
    
    $wrapper->commerce_unit_price->data = commerce_price_component_add(
      $wrapper->commerce_unit_price->value(),
      $component_name,
      $difference,
      TRUE
    );
  }
}

function commerce_reservations_member_price_per_day($line_item, $component_name, $round_mode){
  $product = commerce_product_load($line_item->commerce_product['und'][0]['product_id']);
  if ($product->type != 'reservable_product') {
    return;
  }
  $wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $unit_price = commerce_price_wrapper_value($wrapper, 'commerce_unit_price', TRUE);
  
  if (property_exists($line_item, "field_reservation_dates")){
    $start = strtotime($line_item->field_reservation_dates['und'][0]["value"]);
    $end = strtotime($line_item->field_reservation_dates['und'][0]["value2"]);
    $days_diff = floor(($end - $start) / 86400);
    if ($days_diff < 1){
	    $days_diff = 1;
    }
    $commercial_rate = $product->field_member_cost['und'][0]['amount'];
    $updated_price = $days_diff * $commercial_rate;
    $current_amount = $unit_price['amount'];
    $difference = array(
      'amount' => $updated_price - $current_amount,
      'currency_code' => $unit_price['currency_code'],
      'data' => array(),
    );
   
    // Set the amount of the unit price and add the difference as a component.
    $wrapper->commerce_unit_price->amount = $updated_price;
    
    $wrapper->commerce_unit_price->data = commerce_price_component_add(
      $wrapper->commerce_unit_price->value(),
      $component_name,
      $difference,
      TRUE
    );
  }
}

function commerce_reservations_email_confirmation($line_item, $component_name, $round_mode){
  $order_id = $line_item->order_id;
  $order = commerce_order_load($order_id);
  global $user;
  $params = array(
    'user' => $user,
    'order' => $order,
  );
  drupal_mail('commerce_reservations', 'res_mail', $user->mail, user_preferred_language($user), $params);
}

function commerce_reservations_mail($key, &$message, $params){
  switch($key) {
    case 'res_mail':
      $account = user_load($params['user']->uid);
      $order = $params['order'];
      $line_items = array();
      $line_item_count = 0;
      foreach ($order->commerce_line_items['und'] as $lid){
        $this_item = commerce_line_item_load($lid);
        $line_items[] = $this_item;
        $line_item_count++;
      }
      $langcode = $message['language']->language;
      $message['subject'] = t('Reservation Confirmation');
      $message['body'][] = t("Dear " . $account->field_user_contact_info['und'][0]['first_name'] . " " .  $account->field_user_contact_info['und'][0]['last_name'] . ",\n\nThank you for making a reservation.  Your reservation details are as follows:\n");
      foreach($line_items as $line_item){
        $product = commerce_product_load($line_item->commerce_product['und'][0]['product_id']);
        $start_date = strtotime($line_item->field_reservation_dates['und'][0]['value'] . " UTC");
        date_default_timezone_set($line_item->field_reservation_dates['und'][0]['timezone']);
        $start_date = date('l, F d, Y h:i a', $start_date);
        $end_date = strtotime($line_item->field_reservation_dates['und'][0]['value2'] . " UTC");
        $end_date = date('l, F d, Y h:i a', $end_date);
        $message['body'][] .= $product->title . "\nPickup Date: " . $start_date . "\nReturn Date: " . $end_date . "\n\n";
      }
      break;
    case 'missing_accessories_notice':
      $order = commerce_order_load($params['line_item']->order_id);
      $bad_user = user_load($order->uid);
      $product = commerce_product_load($params['line_item']->commerce_product['und'][0]['product_id']);
      $message['subject'] = t('A reservation was checked in with missing accessories');
      $message['body'][] = $bad_user->name . ' has failed to return the following accessories when they returned a ' . $product->title . ":";
      foreach($params['missing_items'] as $item_id){
        $item = taxonomy_term_load($item_id);
        $message['body'][] .= '<li>' . $item->name . '</li>';
      }
      $path = base_path();
      $message['body'][] .= 'Click <a href = "' . $path . 'admin/commerce/orders/' . $params['line_item']->order_id . '/view"> here </a> to view the order.';
      break;
  }
}

function commerce_reservations_commerce_order_status_info(){
  $order_statuses = array();
  $order_statuses['awaiting_checkout'] = array(
    'name' => 'awaiting_checkout',
    'title' => t('Awaiting Checkout'),
    'state' => 'completed',
  );
  $order_statuses['checked_out'] = array(
    'name' => 'checked_out',
    'title' => t('Checked Out'),
    'state' => 'completed'
  );
  $order_statuses['checked_in'] = array(
    'name' => 'checked_in',
    'title' => t('Checked In'),
    'state' => 'completed'
  );
  $order_statuses['overdue'] = array(
    'name' => 'overdue',
    'title' => t('Overdue'),
    'state' => 'completed'
  );
  $order_statuses['no_show'] = array(
    'name' => 'noshow',
    'title' => t('No Show'),
    'state' => 'completed',
  );
  return $order_statuses;
}

function commerce_reservations_line_item_checkout_form($form, &$form_state, $lid){
  $line_item = commerce_line_item_load($lid);
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $order = commerce_order_load($line_item_wrapper->order_id->value());
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $account = user_load($order_wrapper->uid->value());
  $account_wrapper = entity_metadata_wrapper('user', $account);
  $display_nid = commerce_reservations_entity_display_lookup($line_item->commerce_product['und'][0]['product_id']); 
  $product_display = node_load($display_nid);
  $product_display_wrapper = entity_metadata_wrapper('node', $product_display);
  $date_array = $line_item_wrapper->field_reservation_dates->value();
  $start_date = new DateTime($date_array['value'], new DateTimeZone($date_array['timezone']));
  $end_date = new DateTime($date_array['value2'], new DateTimeZone($date_array['timezone']));

  $invalid_status = array('Checked Out', 'Overdue');
  $available_products = commerce_reservations_items_on_hand($line_item->commerce_product['und'][0]['product_id'], $date_array['value'], $date_array['value2'], $invalid_status);
  $product_options = array();
  foreach ($available_products as $available_id) {
    $available_item = commerce_product_load($available_id);
    $product_options[] = $available_item->sku;
  }

  $tax = taxonomy_vocabulary_machine_name_load('reservable_product_accessories');
  $tree = taxonomy_get_tree($tax->vid);
  $accessories = array();
  foreach ($tree as $term){
    $loaded_term = taxonomy_term_load($term->tid);
    $term_wrapper = entity_metadata_wrapper('taxonomy_term', $loaded_term);
    if ($term_wrapper->field_crp_category->value() == $product_display_wrapper->field_crp_category->value()){
      $accessories[$term_wrapper->tid->value()] = $term_wrapper->name->value();
    }
    if ($loaded_term->field_reservable_product){
      foreach($loaded_term->field_reservable_product as $term_product_reference){
        foreach ($term_product_reference as $key => $info) {
          if ($info['target_id'] == $display_nid) {
            $accessories[$loaded_term->tid] = $loaded_term->name;
          }
        }
      }
    }
  }
  
  $form['lid'] = array(
    '#markup' => '<p>You are checking out ' . $account_wrapper->name->value() . "'s reservation for " . $product_display_wrapper->title->value() . ".</br>" . " From " . $start_date->format('l, F d, Y h:i a') . "</br> To " . $end_date->format('l, F d, Y h:i a'),
  );
  $form['product_picker'] = array(
    '#type' => 'select',
    '#title' => 'Which ' . $product_display_wrapper->title->value() .  ' is the user checking out?',
    '#options' => drupal_map_assoc($product_options),
    '#default_value' => 0
  );
  if (count($accessories) > 0) {
    $form['accessories'] = array(
      '#type' => 'checkboxes',
      '#title' => 'Select all accessories the user is checking out.',
      '#options' => $accessories,
    );
  }
  $form['start_date'] = array(
    '#type' => 'hidden',
    '#value' => $date_array['value'],
  );
  $form['end_date'] = array(
    '#type' => 'hidden',
    '#value' => $date_array['value2'],
  );
  $form['opi'] = array(
    '#type' => 'hidden',
    '#value' => $line_item->commerce_product['und'][0]['product_id'],
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Checkout')
  );
  $form['cancel'] = array(
    '#markup' => '<a href = "../todays_reservations">Cancel</a>'
  );
  return $form;
}

function commerce_reservations_line_item_checkout_form_submit($form, &$form_state){
  $line_id = $form_state['build_info']['args'][0];
  $line_item = commerce_line_item_load($line_id);
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $product = commerce_product_load_by_sku($form_state['values']['product_picker']);
  $product_wrapper = entity_metadata_wrapper('commerce_product', $product);
  $line_item_wrapper->commerce_product->set($product_wrapper->product_id->value());
  $line_item_wrapper->line_item_label->set($product_wrapper->sku->value());
  $line_item_wrapper->field_checkout_status->set('Checked Out');
  $checked_out_accessories = array();
  if (!is_null($form_state['input']['accessories'])) {
    foreach($form_state['input']['accessories'] as $accessory){
      if ($accessory){
        $checked_out_accessories[] = $accessory;
      }
    }
  }
  $line_item_wrapper->field_checked_out_accessories->set($checked_out_accessories);
  $line_item_wrapper->save();
  $form_state['redirect'] = 'administer_reservations';
}

function commerce_reservations_cancel_reservation_access($lid) {
  global $user;
  $line_item = commerce_line_item_load($lid);
  $order = commerce_order_load($line_item->order_id);
  $status = $line_item->field_checkout_status[LANGUAGE_NONE][0]['value'];
  if ($status == 'Awaiting Checkout') { 
    if (user_access('administer commerce reservations')) {
      return true;
    }
    if (user_access('cancel own commerce reservations') && $user->uid == $order->uid) {
      return true;
    }
  }
  return false;
}

function commerce_reservations_line_item_cancel_form($form, &$form_state, $lid){
  $form['lid'] = array('#type' => 'hidden', '#value' => $lid);
  $question = t('Are you sure you want to cancel this reservation?');
  $description = '<strong>'.t('This action cannot be undone. Our system does not currently support automatically refunding any payments made for this reservation. If you need a refund please contact station personnel to cancel and refund your reservation.').'</strong>'; 
  $form = confirm_form($form, $question, 'administer_reservations', $description);
  return $form;
}

function commerce_reservations_line_item_cancel_form_submit($form, &$form_state) {
  if (!empty($form_state['values']['confirm']) && $form_state['values']['confirm'] == 1) {
    if (!empty($form_state['values']['lid']) && is_numeric($form_state['values']['lid'])) {
      commerce_line_item_delete($form_state['values']['lid']);
      drupal_set_message('Reservation cancelled.');
    }
  }
}

function commerce_reservations_line_item_noshow_form($form, &$form_state, $lid){
  $form['lid'] = array('#type' => 'hidden', '#value' => $lid);
  $form = confirm_form($form, 'Are you sure you want to mark this reservation as no show?', 'administer_reservations');
  return $form;
}

function commerce_reservations_line_item_noshow_form_submit($form, &$form_state) {
  if (!empty($form_state['values']['confirm']) && $form_state['values']['confirm'] == 1) {
    if (!empty($form_state['values']['lid']) && is_numeric($form_state['values']['lid'])) {
      $line_item = commerce_line_item_load($form_state['values']['lid']);
      $line_item->field_checkout_status[LANGUAGE_NONE][0]['value'] = 'No Show';
      commerce_line_item_save($line_item);
      drupal_set_message('Reservation set to noshow.');
    }
  }
}

function commerce_reservations_line_item_checkin_form($form, &$form_state, $lid){
  if (empty($form_state['stage']) || $form_state['stage'] != 'missing_accessory') {
    $form = commerce_reservations_line_item_checkin_primary_form($form, $form_state, $lid);
  }
  else {
    $form = commerce_reservations_line_item_checkin_missing_accessory_form($form, $form_state, $lid); 
  }
  return $form;
}

function commerce_reservations_line_item_checkin_primary_form($form, &$form_state, $lid) {
  $line_item = commerce_line_item_load($lid);
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);

  $order = commerce_order_load($line_item_wrapper->order_id->value());
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  $account = user_load($order_wrapper->uid->value());
  $account_wrapper = entity_metadata_wrapper('user', $account);

  $date_array = $line_item_wrapper->field_reservation_dates->value();
  $start_date = new DateTime($date_array['value'], new DateTimeZone($date_array['timezone']));
  $end_date = new DateTime($date_array['value2'], new DateTimeZone($date_array['timezone']));
  $product = $line_item_wrapper->commerce_product->value();
  $product_wrapper = entity_metadata_wrapper('commerce_product', $product);
  $fields = field_info_field('field_res_product_status');
  $status_options = $fields['settings']['allowed_values'];
  $checked_options = array();
  foreach ($status_options as $key => $option){
    if ($product->field_res_product_status){
      foreach ($product_wrapper->field_res_product_status->getIterator() as $old_val){
        if ($option == $old_val->value()){
          $checked_options[]  = $option;
        }
      }
    }
  }
  $accessories = array();
  foreach($line_item_wrapper->field_checked_out_accessories->getIterator() as $term_wrapper){
    $accessories[$term_wrapper->tid->value()] = $term_wrapper->name->value();
  }
  if ($product->field_reservable_product_notes){
    $product_notes = $product_wrapper->field_reservable_product_notes->value();
  } else{
    $product_notes = '';
  }

  $form['lid'] = array(
    '#markup' => '<p>You are checking in ' . $account_wrapper->name->value() . "'s reservation for " . $product_wrapper->title->value() . ".</br>" . " From " . $start_date->format('l, F d, Y h:i a') . "</br> To " . $end_date->format('l, F d, Y h:i a') . '</br>' . 'User checked out sku number: ' . $product_wrapper->sku->value() . '</br>',
  );
  $form['item_status'] = array(
    '#type' => 'checkboxes',
    '#options' => $status_options,
    '#default_value' => $checked_options,
  );
  $form['item_notes'] = array(
    '#type' => 'textarea',
    '#title' => 'Product notes',
    '#default_value' => $product_notes,
  );
  $form['accessories'] = array(
    '#type' => 'checkboxes',
    '#title' => 'These are the accessories the user checked out.</br>Please check all accessories the user is returning.',
    '#options' => $accessories,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Check In')
  );
  $form['cancel'] = array(
    '#markup' => commerce_reservations_destination_link('Cancel'),
  );

  return $form;
}

function commerce_reservations_destination_link($label) {
  $destination = drupal_get_destination();
  $url_parts = parse_url(urldecode($destination['destination']));
  parse_str($url_parts['query'], $query);
  $link = l($label, $url_parts['path'], array('query' => $query));
  return $link;
}

function commerce_reservations_line_item_checkin_missing_accessory_form($form, &$form_state, $lid) {
  $selected_items = array();
  $missing_accessories = commerce_reservations_line_item_checkin_missing_accessories ($form_state['storage']['step1']['accessories']);
  foreach ($form_state['storage']['step1']['accessories'] as $index => $term_id) {
    if ($term_id){
      $selected_items[] = $term_id;
    }
  }

  $missing_text = commerce_reservations_line_item_checkin_missing_accessories_text ($missing_accessories);
  $description = '<strong>You attempted to check in a reservation that is missing the following accessories:</strong>';
  $description .= $missing_text;
  $description .= '<br />If these accessories are missing please confirm below and the station director will be notified. Otherwise, please check the boxes on the accessories below to indicate they are being returned.';

  $line_item = commerce_line_item_load($lid);
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $accessories = array();
  foreach($line_item_wrapper->field_checked_out_accessories->getIterator() as $term_wrapper){
    $accessories[$term_wrapper->tid->value()] = $term_wrapper->name->value();
  }

  $form['missing_accessory_warning'] = array( 
    '#markup' => $description,
  );
  
  $form['accessories'] = array(
    '#type' => 'checkboxes',
    '#title' => 'These are the accessories the user checked out.</br>Please check all accessories the user is returning.',
    '#options' => $accessories,
    '#default_value' => $selected_items,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Confirm accessories')
  );
  $form['cancel'] = array(
    '#markup' => commerce_reservations_destination_link('Cancel'),
  );

  return $form;
}

function commerce_reservations_line_item_checkin_form_submit($form, &$form_state){
  //setup entities
  $line_id = $form_state['build_info']['args'][0];
  $line_item = commerce_line_item_load($line_id);
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $product = $line_item_wrapper->commerce_product->value();
  $product_wrapper = entity_metadata_wrapper('commerce_product', $product);

  if (!empty($form_state['stage']) && $form_state['stage'] == 'missing_accessory') {
    $accessories = $form_state['values']['accessories'];
    $missing = commerce_reservations_line_item_checkin_missing_accessories ($accessories);
    if ($missing) { 
      $missing_text = commerce_reservations_line_item_checkin_missing_accessories_text ($missing);
      $email = variable_get('cr_admin_email');
      global $language;
      $params = array(
        'line_item' => $line_item,
        'missing_items' => $missing,
      );
      drupal_mail('commerce_reservations', 'missing_accessories_notice', $email, $language->language, $params);
    }

    commerce_reservations_line_item_checkin_update_line_item ($line_item_wrapper, $accessories);
  }
  else {
    $accessories = $form_state['input']['accessories'];
    commerce_reservations_line_item_checkin_update_product ($form_state, $product_wrapper);

    //if there are missing items go to next form state for confirmation 
    if (commerce_reservations_line_item_checkin_missing_accessories ($accessories)) {
      $form_state['storage']['step1'] = $form_state['values'];
      $form_state['stage'] = 'missing_accessory';
      $form_state['rebuild'] = TRUE;
      return;
    }

    commerce_reservations_line_item_checkin_update_line_item ($line_item_wrapper, $accessories);
  }
}

function commerce_reservations_line_item_checkin_missing_accessories ($form_accessories) {
  $missing_items = array();
  if (!empty($form_accessories)) {
    foreach ($form_accessories as $index => $term_id) {
      if (!$term_id){
        $missing_items[] = $index;
      }
    }

    if (count($missing_items > 0)) {
      return $missing_items;
    }
  }

  return false;
}

function commerce_reservations_line_item_checkin_missing_accessories_text ($missing_accessories) {
  $text = '';
  foreach ($missing_accessories as $tid){
    $term = taxonomy_term_load($tid);
    $text .= '<li>' . $term->name .'</li>';
  }

  return $text;
}

function commerce_reservations_line_item_checkin_update_line_item ($line_item_wrapper, $accessories) {
  $line_item_wrapper->field_checkout_status->set('Checked In');
  $returned_accessories = array();
  if (!empty($returned_accessories)) {
    foreach ($accessories as $index => $item){
      if ($item) {
        $returned_accessories[] = $index;
      }
    }
  }
  if (count($returned_accessories) > 0) {
    $line_item_wrapper->field_returned_accessories->set($returned_accessories);
  }
  $line_item_wrapper->save();
}

function commerce_reservations_line_item_checkin_update_product ($form_state, $product_wrapper) {
  $notes = $form_state['values']['item_notes'];
  $index = 0;
  $product_wrapper->field_reservable_product_notes->set($notes);
  $status_values = array();
  foreach ($form_state['values']['item_status'] as $value){
    $status_values[] = $value;
    $index++;
  }
  $product_wrapper->field_res_product_status->set($status_values);
  $product_wrapper->save();
}

function missing_accessories_confirm($form, &$form_state, $line_id, $missing_items_string){
  $missing_items = explode('-', $missing_items_string);
  foreach($missing_items as $tid){
    $loaded_missing_items[] = taxonomy_term_load($tid);
  }
  $line_item = commerce_line_item_load($line_id);
  $form['#submit'][]  = 'missing_accessories_confirm_form_submit';
  $question = 'You are about to check in a reservation that is missing accessories.';
  $description = 'You are about to check in a reservation that is missing the following accessories:';
  foreach($loaded_missing_items as $item){
    $description .= '<li>' . $item->name . '</li>';
  }
  $description2 = 'This action will notify a station administrator.<br/>  Do you wish to continue?';
  $description = $description . '<br/>' . $description2;
  $path = 'administer_reservations';
  return confirm_form($form, $question, $path, $description, t('Yes'), t('NO'));
}

function missing_accessories_confirm_form_submit($form, &$form_state){
  $line_id = $form_state['build_info']['args'][0];
  $line_item = commerce_line_item_load($line_id);
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $checked_out_items = $line_item_wrapper->field_checked_out_accessories->value();
  $missing_items = explode('-', $form_state['build_info']['args'][1]);
  $returned_items = array();
  foreach ($checked_out_items as $item) {
    if (in_array($item->tid, $missing_items)) {
      $returned_items[] = $item->tid;
    }
  }
  $line_item_wrapper->field_returned_accessories->set($returned_items);
  $line_item_wrapper->field_checkout_status->set('Checked In');
  $line_item_wrapper->save();
  $email = variable_get('cr_admin_email');
  global $language;
  $params = array(
    'line_item' => $line_item,
    'missing_items' => $missing_items,
  );
  drupal_mail('commerce_reservations', 'missing_accessories_notice', $email, $language->language, $params);
  $form_state['redirect'] = 'administer_reservations';
}

/*
 * Implements hook_cron()
 */

function commerce_reservations_cron(){
  $conditions = array(
    'type' => 'reservable_product'
  );
  $line_items =  commerce_line_item_load_multiple($line_item_ids = array(), $conditions);
  foreach ($line_items as $line_item){
    if (!empty($line_item->field_reservation_dates)) {
      $end_date = strtotime($line_item->field_reservation_dates['und'][0]['value2'] . " UTC");
      if ($end_date < time()){
        if (!empty($line_item->field_checkout_status['und']) && $line_item->field_checkout_status['und'][0]['value'] == "Checked Out"){
          $line_item->field_checkout_status['und'][0]['value'] = "Overdue";
          commerce_line_item_save($line_item);
        }
      }
    }
  }
}

function commerce_reservations_settings_form($form, &$form_state){
  $total = variable_get('cr_closed_total');
  $old_dates = array();
  for ($i = 0; $i < $total; $i++){
    $variable = 'cr_closed_dates_' . $i;
    $old_dates[] = variable_get($variable);
  }
  $form['header'] = array(
    '#markup' => '<h1>Reservations Settings</h1>',
  );
  $allow_commercial = variable_get('cr_allow_commercial');
  $email_confirm = variable_get('cr_email_admin_confirm');
  if ($email_confirm){
    $checkbox_default = 1;
    $email_default = variable_get('cr_admin_email');
  } else{
    $checkbox_default = 0;
    $email_default = '';
  }
  $form['allow_commercial'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow Commercial Rentals'),
    '#default_value' => $allow_commercial,
  );
  $form['notify_admin']['email_confirm'] = array(
    '#type' => 'checkbox',
    '#title' => t('Notify station administrator of missing accessories?'),
    '#default_value' => $checkbox_default,
  );
  $form['notify_admin']['email'] = array(
    '#type' => 'textfield',
    '#title' => t('Notification should be sent to this email address:'),
    '#default_value' => $email_default,
  );
  $form['cr_expired_cart_warning'] = array(
    '#type' => 'checkbox',
    '#title' => t('Warn users after 10 minutes of an incomplete order'),
    '#default_value' => variable_get('cr_expired_cart_warning', 0),
  );
  $form['cr_hide_certs'] = array(
    '#type' => 'checkbox',
    '#title' => t('Hide certifications in production information box on reservation page?'),
    '#default_value' => variable_get('cr_hide_certs', 0),
  );
  $availability_items = commerce_reservations_availability_form_items($form, $form_state);
  $form += $availability_items;
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Save Settings',
  );
  return $form;
}

function commerce_reservations_availability_var_get($key, $default, $nid = null) {
  if ($nid) {
    return variable_get($nid . '_' . $key);
  }
  else {
    return variable_get($key, $default);
  }
}

function commerce_reservations_availability_var_set($key, $value, $nid = null) {
  if (!empty($nid)) {
    variable_set($nid . '_' . $key, $value);
  }
  else {
    variable_set($key, $value);
  }

  return;
}

function commerce_reservations_availability_var_del($key, $nid = null) {
  if (!empty($nid)) {
    variable_del($nid . '_' . $key);
  }
  else {
    variable_del($key);
  }
  return;
}

function commerce_reservations_availability_form_items($form, &$form_state) {
  if (!empty($form['nid']['#value']) && is_numeric($form['nid']['#value'])) {
    $key_nid = $form['nid']['#value'];
  }
  else {
    $key_nid = false;
  }

  $total = commerce_reservations_availability_var_get('cr_closed_total', NULL, $key_nid);
  $form = array();

  $form['cr_max_reservation_length'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum hours for a single reservation:'),
    '#default_value' => commerce_reservations_availability_var_get('cr_max_reservation_length', 0, $key_nid),
    '#description' => t('Enter 0 for no limit'),
    '#size' => 10,
  );

  $form['cr_max_quantity'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of an item that can be checked out in a single reservation:'),
    '#default_value' => commerce_reservations_availability_var_get('cr_max_quantity', 0, $key_nid),
    '#description' => t('Enter 0 for no limit'),
    '#size' => 10,
  );

  $form['cr_reservation_window'] = array(
    '#type' => 'textfield',
    '#title' => t('How many days out can reservations be made?'),
    '#default_value' => commerce_reservations_availability_var_get('cr_reservation_window', 90, $key_nid),
    '#description' => t('Currently this number cannot exceed 90 days'),
    '#size' => 10,
  );

  $old_dates = array();
  for ($i = 0; $i < $total; $i++){
    $variable = 'cr_closed_dates_' . $i;
    $old_dates[] = commerce_reservations_availability_var_get($variable, NULL, $key_nid);
  }
  $form['closed_dates'] = array(
    '#prefix' => '<div id="closed_dates">', 
    '#suffix' => '</div>',
  );
  if ($key_nid) {
    $closed_dates_label = t('Add dates that this item is unavailable');
  }
  else {
    $closed_dates_label = t('Select a holiday or other day the station is closed.');
  }
  for ($i = 0; $i < $total + 1; $i++){
    $key = 'dates_' . $i;
    if ($i < $total){
      $value = $old_dates[$i];
      $value_array = explode('-', $value);
      $date_string = $value_array[2] . '-' .  $value_array[0] . '-' .  $value_array[1];
    } else {
      $date_string = '';
    }

    $form['closed_dates'][$key] = array(
      '#type' => 'date_popup',
      '#date_format' => 'm-d-Y',
      '#title' => $closed_dates_label,
      '#default_value' => $date_string,
    );
  }
  if (array_key_exists('triggering_element', $form_state)){
    if ($form_state['triggering_element']['#value'] == 'add another'){
      foreach($form['closed_dates'] as $key => $value){
        $index = substr($key, 6);
        if (is_numeric($index)){
          $index++;
          $date_key = 'dates_' . $index;
          $form['closed_dates'][$date_key] = array(
            '#type' => 'date_popup',
            '#date_format' => 'm-d-Y',
            '#title' => $closed_dates_label,
            '#default_value' => '',
          );
        }
      }
    }
  }
  $form['add_dates'] = array(
    '#type' => 'button',
    '#value' => t('add another'),
    '#description' => t('Add another date'),
    '#ajax' => array(
      'callback' => 'more_dates_js',
      'wrapper' => 'closed_dates',
      'method' => 'replace',
      'effect' => 'fade',
    ),
  );
  $days = commerce_reservations_week_days();
  $closed_days = array();
  $closed_attributes = array();
  foreach ($days as $day){
    $variable = 'cr_' . $day;
    $setting = commerce_reservations_availability_var_get($variable, NULL, $key_nid);
    if ($setting == 'closed'){
      $closed_days[] = $day;
    }  
  }

  if ($key_nid) {
    $closed_days_label = t('Select days that this item is never available');
  }
  else {
    $closed_days_label = t('Select days that the location is closed.');
  }
  $form['weekend_days'] = array(
    '#type' => 'checkboxes',
    '#title' => $closed_days_label,
    '#options' => $days,
    '#default_value' => $closed_days,
  );


  if ($key_nid) {
    $hours_op_label = t('Hours this item is available');
  }
  else {
    $hours_op_label = t('Hours of operation');
  }
  $form['operation_hours'] = array(
    '#type' => 'fieldset',
    '#title' => $hours_op_label,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  
  foreach ($days as $day){
    $lower_day = strtolower($day);
    $div = '<div id = "' . $lower_day . '">';
    $open_day = 'open_' . $lower_day;
    $close_day = 'close_' . $lower_day;
    $title_open = 'Start availability on ' . $day;
    $title_close = 'End availability on ' . $day;
    $form['operation_hours'][$lower_day] = array(
      '#prefix' => $div,
      '#suffix' => '</div>',
    );
    $variable = 'cr_' . $day . '_hours';
    $value = commerce_reservations_availability_var_get($variable, NULL, $key_nid);
    if ($value && !empty($value['open']) && !empty($value['closed'])){
      $value = $value['open'];
      $value_array = explode(':', $value);
      $minute_array = explode(' ', $value_array[1]);
      $hour = $value_array[0];
      $minute  = $minute_array[0];
      $time_string = $hour . ':' . $minute . ' ' . $minute_array[1];
    } else{
      $time_string = '';
    }
    $form['operation_hours'][$lower_day][$open_day] = array(
      '#prefix' => '<div id="open">', 
      '#suffix' => '</div>',
      '#type' => 'textfield',
      '#size' => '10',
      '#title' => t($title_open),
      '#description' => t('e.g. 10:30 am'),
      '#default_value' => $time_string,
    );
    $value = commerce_reservations_availability_var_get($variable, NULL, $key_nid);
    if ($value && !empty($value['open']) && !empty($value['closed'])){
      $value = $value['closed'];
      $value_array = explode(':', $value);
      $minute_array = explode(' ', $value_array[1]);
      $hour = $value_array[0];
      $minute  = $minute_array[0];
      $time_string = $hour . ':' . $minute . ' ' . $minute_array[1];
    } else{
      $time_string = '';
    }
    $form['operation_hours'][$lower_day][$close_day] = array(
      '#prefix' => '<div id="close">', 
      '#suffix' => '</div>',
      '#type' => 'textfield',
      '#size' => '10',
      '#description' => t('e.g. 8:30 pm'),
      '#title' => t($title_close),
      '#default_value' => $time_string,
    );
  }

  $form['cr_availability_blocking'] = array(
    '#type' => 'checkbox',
    '#title' => t('Set times and dates to blocking?'),
    '#description' => t('If this is checked, users will not be able to make reservations across unavailable times. For instance, if you make reservations unavailable on Wednesdays and this box is checked, users will not be able to make a reservation from Tuesday -> Thursday.'),
    '#default_value' => commerce_reservations_availability_var_get('cr_availability_blocking', 0, $key_nid),
  );

  return $form;
}

function commerce_reservations_availability_items_submit($form, &$form_state) {
  if (!empty($form['nid']['#value']) && is_numeric($form['nid']['#value'])) {
    $key_nid = $form['nid']['#value'];
  }
  else {
    $key_nid = FALSE;
  }

  commerce_reservations_availability_var_set('cr_max_reservation_length', $form_state['input']['cr_max_reservation_length'], $key_nid);
  commerce_reservations_availability_var_set('cr_max_quantity', $form_state['input']['cr_max_quantity'], $key_nid);
  commerce_reservations_availability_var_set('cr_reservation_window', $form_state['input']['cr_reservation_window'], $key_nid);
  commerce_reservations_availability_var_set('cr_availability_blocking', $form_state['input']['cr_availability_blocking'], $key_nid);

  $total = 0;
  $old_total = commerce_reservations_availability_var_get('cr_closed_total', NULL, $key_nid);
  for ($i = 0; $i < $old_total; $i++){
    $variable = 'cr_closed_dates_' . $i;
    commerce_reservations_availability_var_get($variable, $key_nid);
  }
  foreach($form_state['input'] as $key => $value){
    if (substr($key, 0,5) == 'dates'){
      if (!empty($value['date'])){
        $variable = 'cr_closed_' . $key;
        $var_val = $value['date'];
        commerce_reservations_availability_var_set($variable, $var_val, $key_nid);
        $total++;
      }
    }
  }
  commerce_reservations_availability_var_set('cr_closed_total', $total, $key_nid);
  foreach ($form_state['input']['weekend_days'] as $key => $value){
    $day = 'cr_' . $key;
    $variable = $day . '_hours';
    if ($value){
      commerce_reservations_availability_var_set($day, 'closed', $key_nid);
      commerce_reservations_availability_var_del($variable, $key_nid);
    } else{
      commerce_reservations_availability_var_set($day, 'open', $key_nid);
      $index_open = 'open_' . strtolower($key);
      $index_closed = 'close_' . strtolower($key);
      $hours = array(
        'open' => $form_state['input'][$index_open],
        'closed' => $form_state['input'][$index_closed],
      );
      commerce_reservations_availability_var_set($variable, $hours, $key_nid);
    }
  }
}

function commerce_reservations_settings_form_submit($form, &$form_state){
  if ($form_state['values']['allow_commercial'] == 1){
	  variable_set('cr_allow_commercial', 1);
  } else{
	  variable_set('cr_allow_commercial', 0);
  }
  variable_set('cr_expired_cart_warning', $form_state['input']['cr_expired_cart_warning'], 0);
  variable_set('cr_hide_certs', $form_state['input']['cr_hide_certs'], 0);

  if ($form_state['input']['email_confirm']){
    variable_set('cr_email_admin_confirm', 1);
    variable_set('cr_admin_email', $form_state['input']['email']);
  } else{
    variable_set('cr_email_admin_confirm', 0);
    $email = variable_get('cr_admin_email');
    if ($email){
      variable_del($email);
    }
  }

  commerce_reservations_availability_items_submit($form, $form_state);
}

/*
 * Callback for AJAX rendering of more date fields
 */
 
function more_dates_js($form, &$form_state){
  if (empty($form['closed_dates'])) {
    return $form['reservable_product_availability']['closed_dates'];
  }

  return $form['closed_dates'];
}

/* 
 * Utility function for a days of the week array
 */
 
function commerce_reservations_week_days(){
  $days = array(
    'Sunday' => 'Sunday',
    'Monday' => 'Monday',
    'Tuesday' => 'Tuesday',
    'Wednesday' => 'Wednesday',
    'Thursday' => 'Thursday',
    'Friday' => 'Friday',
    'Saturday' => 'Saturday',
  );
  return $days;
}

function commerce_reservations_entity_display_lookup($product_id) {
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node', '=')
    ->entityCondition('bundle', 'reservable_product_display', '=')
    ->fieldCondition('field_crp_product_reference', 'product_id', $product_id, '=')
    ->execute();

  foreach($result as $type) {
    foreach($type as $key => $info) {
      if($info->nid) {
        return $info->nid;
      }
    } 
  }

  return false;
}

function commerce_reservations_line_item_duration ($line_item) {  
  if (empty($line_item->field_reservation_dates[LANGUAGE_NONE][0]['value']) || empty($line_item->field_reservation_dates[LANGUAGE_NONE][0]['value2'])) {
    return FALSE;
  }

  //calculate duration of reservation
  $start = strtotime($line_item->field_reservation_dates[LANGUAGE_NONE][0]['value']);
  $end = strtotime($line_item->field_reservation_dates[LANGUAGE_NONE][0]['value2']);
  $total_hours = ($end-$start) / 3600;

  return $total_hours;
}

function commerce_reservations_add_to_cart_form ($product_id = null, $render = true) {
    if (empty($product_id)) {
      $query = "SELECT product_id FROM {commerce_product} WHERE type = :type AND status = :status LIMIT 1";
      $product_id = db_query($query, array(':type' => 'reservable_product', ':status' => 1))->fetchField();
    }

    if (!empty($product_id)) {
      $product = commerce_product_load($product_id);
      if (!empty($product)) {
        $default_quantity = 1;
        $line_item_type = 'reservable_product';
        $product_ids = array($product_id);

        // Build the line item we'll pass to the Add to Cart form.
        $line_item = commerce_product_line_item_new($product, $default_quantity, 0, array(), $line_item_type);
        $line_item->data['context']['product_ids'] = $product_ids;
        $line_item->data['context']['display_path'] = 'reservations';

        // Store the View data in the context data array as well.
        $line_item->data['context']['view'] = array(
          'view_name' => 'reservation_calendar',
          'display_name' => 'page_1',
          'human_name' => 'Reservation Calendar Page',
        );

        // Generate a form ID for this add to cart form.
        $form_id = commerce_cart_add_to_cart_form_id($product_ids, $default_quantity);

        $form = commerce_reservations_build_form($form_id, $line_item, false, array());

        if ($render && empty($_POST['product_id'])) {
          $rendered = drupal_render($form);
          print $rendered;
        }
      }
    }

    if ($render) {
      print '';
    }
}

function commerce_reservations_build_form($form_id) {
 $form_state = array();
 $args = func_get_args();
 // Remove $form_id from the arguments.
 array_shift($args);
 $form_state['build_info']['args'] = $args;
 $form_state['cache'] = true;

 return drupal_build_form($form_id, $form_state);
}

function commerce_reservations_product_checkout_status($product_id, $start_date, $end_date, $exclude_id = null) {
  $reservations = commerce_reservations_product_reservations($product_id, $start_date, $end_date, $exclude_id = null);
  $reservation_status = 'Available';
  foreach ($reservations as $reservation) {
    if ($reservation->field_checkout_status_value == 'Checked Out' || $reservation->field_checkout_status_value == 'Overdue') {
      return $reservation->field_checkout_status_value;
    }

    if (is_null($reservation->field_checkout_status_value)) {
        $reservation_status = 'Pending Reservation';
    }else{
      $reservation_status = $reservation->field_checkout_status_value;
    }
  }
  
  return $reservation_status;
}

function commerce_reservations_product_reservations($product_id, $start_date, $end_date, $exclude_id = null) {
  $product = commerce_product_load($product_id);
  $query = "
    SELECT commerce_line_item.line_item_id, field_data_field_checkout_status.field_checkout_status_value,
    field_data_field_reservation_dates.field_reservation_dates_value, field_data_field_reservation_dates.field_reservation_dates_value2 
    FROM {commerce_line_item} 
    JOIN {field_data_field_reservation_dates} ON field_data_field_reservation_dates.entity_id = commerce_line_item.line_item_id
    LEFT JOIN {field_data_field_checkout_status} ON field_data_field_checkout_status.entity_id = commerce_line_item.line_item_id
    WHERE commerce_line_item.line_item_label = :sku
    AND (
      DATE_ADD(field_data_field_reservation_dates.field_reservation_dates_value, INTERVAL 1 SECOND) BETWEEN :start_date AND :end_date 
      OR
      DATE_SUB(field_data_field_reservation_dates.field_reservation_dates_value2, INTERVAL 1 SECOND) BETWEEN :start_date AND :end_date
      OR
      (DATE_ADD(field_data_field_reservation_dates.field_reservation_dates_value, INTERVAL 1 SECOND) < :start_date AND
       DATE_SUB(field_data_field_reservation_dates.field_reservation_dates_value2, INTERVAL 1 SECOND) > :end_date)
    )";
  $results = db_query($query, array(':start_date' => $start_date, ':end_date' => $end_date, ':sku' => $product->sku));
  $reservations = array();
  foreach ($results as $result) {
    if ($exclude_id != $result->line_item_id) {
      $reservations[$result->line_item_id] = $result;
    }
  }

  return $reservations;
}

function commerce_reservations_product_quantity_available($product_id, $start_date, $end_date, $exclude_id = null) {
  $display = commerce_reservations_entity_display_lookup($product_id);
  $display_node = node_load($display);
  $all_reservations = array();
  if (!empty($display_node->field_crp_product_reference['und'])) {
    $max_quantity = count($display_node->field_crp_product_reference['und']);
    $reservation_count = 0;
    foreach ($display_node->field_crp_product_reference['und'] as $key => $info) {
      $reservations = commerce_reservations_product_reservations($info['product_id'], $start_date, $end_date, $exclude_id = null);
      foreach ($reservations as $reservation) {
        if (is_null($reservation->field_checkout_status_value) || 
        $reservation->field_checkout_status_value == 'Checked Out' || 
        $reservation->field_checkout_status_value == 'Overdue' ||
        $reservation->field_checkout_status_value == 'Awaiting Checkout') {
          $all_reservations[] = array(
            'start' => strtotime($reservation->field_reservation_dates_value),
            'end' => strtotime($reservation->field_reservation_dates_value2),
            'line_id_array' => array($reservation->line_item_id),
            'count' => 1
          );
        }
      }
    }
    $overlaps = check_overlaps($all_reservations, $all_reservations);
    foreach ($overlaps as $overlap) {
      if ($overlap['count'] > $reservation_count) { 
        $reservation_count = $overlap['count'];
      }
    }
  }else{
    $max_quantity = 0;
    $reservation_count = 1;
  }
  if ($reservation_count >= $max_quantity) {
    return 0;
  }else{
    return $max_quantity - $reservation_count;
  }
}

//TODO: BRIAN an odd situation can occur if a checkout contains overlapping reservations
//by the time it gets to the line item save -- basically the same sku will get assigned
//because no available sku will be found. It shouldn't be possible but at some point
//we should probably make this fail if no swap_product_id is found...
function commerce_reservations_entity_presave($entity, $type) {
  if ($type == 'commerce_line_item' && $entity->type == 'reservable_product') {
    $product_id = $entity->commerce_product[LANGUAGE_NONE][0]['product_id'];
    $start_date = $entity->field_reservation_dates[LANGUAGE_NONE][0]['value'];
    $end_date = $entity->field_reservation_dates[LANGUAGE_NONE][0]['value2'];
    $exclude_id = null;
    if (!empty($entity->line_item_id)) {
      $exclude_id = $entity->line_item_id;
    }
    $checkout_status = commerce_reservations_product_checkout_status($product_id, $start_date, $end_date, $exclude_id);
    if ($checkout_status != 'Available') {
      $exclude_ids = array();
      $exclude_ids[] = $product_id;
      $swap_product_id = commerce_reservations_available_product_id($product_id, $start_date, $end_date, $exclude_ids);
      if ($swap_product_id) {
        $swap_product = commerce_product_load($swap_product_id);
        $entity->commerce_product[LANGUAGE_NONE][0]['product_id'] = $swap_product_id;
        $entity->line_item_label = $swap_product->sku;
      }
    }
  }
}

function commerce_reservations_check_availability($form, &$form_state) {
  if ($form_state['line_item']->type == 'reservable_product') {
    $available_items = commerce_reservations_product_quantity_available(
      $form_state['line_item']->commerce_product[LANGUAGE_NONE][0]['product_id'],
      $form_state['line_item']->field_reservation_dates[LANGUAGE_NONE][0]['value'], 
      $form_state['line_item']->field_reservation_dates[LANGUAGE_NONE][0]['value2']);

    if ($available_items < $form_state['values']['quantity']) {
      $message = t('This product is not available for checkout during the time you selected. Please be sure to allow the reservation calendar to load fully before attempting to select your time.');
      form_set_error('quantity', $message);
      drupal_goto('reservations');
    }
  }
}

function commerce_reservations_available_product_id($product_id, $start_date, $end_date, $exclude_ids = array()) {
  $display_nid = commerce_reservations_entity_display_lookup($product_id);
  $display_node = node_load($display_nid);

  foreach ($display_node->field_crp_product_reference[$display_node->language] as $key => $info) {
    if (empty($exclude_ids) || !in_array($info['product_id'], $exclude_ids)) {
      $checkout_status = commerce_reservations_product_checkout_status($info['product_id'], $start_date, $end_date);
      if ($checkout_status == 'Available') {
        return $info['product_id'];
      }
    }
  }

  return false;
}

function commerce_reservations_items_on_hand($product_id, $start_date, $end_date, $invalid_status = array('Checked Out', 'Overdue')) {
  $display_nid = commerce_reservations_entity_display_lookup($product_id);
  $display_node = node_load($display_nid);

  $available = array();
  foreach ($display_node->field_crp_product_reference[$display_node->language] as $key => $info) {
    $checkout_status = commerce_reservations_product_checkout_status($info['product_id'], $start_date, $end_date);
    if (!in_array($checkout_status, $invalid_status)) {
      $available[] = $info['product_id'];
    }
  }

  return $available;
}
